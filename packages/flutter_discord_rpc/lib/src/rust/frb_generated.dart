// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.5.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/api.dart';
import 'api/types.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiApiInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.5.0';

  @override
  int get rustContentHash => 1597128205;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'flutter_discord_rpc',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<void> crateApiApiDiscordClearActivity();

  Future<void> crateApiApiDiscordClose();

  Future<void> crateApiApiDiscordConnect();

  Future<void> crateApiApiDiscordDispose();

  Future<void> crateApiApiDiscordInit({required String clientId});

  Future<void> crateApiApiDiscordReconnect();

  Future<void> crateApiApiDiscordSetActivity({required RPCActivity activity});

  Future<void> crateApiApiInitApp();
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateApiApiDiscordClearActivity() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiDiscordClearActivityConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiDiscordClearActivityConstMeta =>
      const TaskConstMeta(
        debugName: "discord_clear_activity",
        argNames: [],
      );

  @override
  Future<void> crateApiApiDiscordClose() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiDiscordCloseConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiDiscordCloseConstMeta => const TaskConstMeta(
        debugName: "discord_close",
        argNames: [],
      );

  @override
  Future<void> crateApiApiDiscordConnect() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 3, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiDiscordConnectConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiDiscordConnectConstMeta => const TaskConstMeta(
        debugName: "discord_connect",
        argNames: [],
      );

  @override
  Future<void> crateApiApiDiscordDispose() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiDiscordDisposeConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiDiscordDisposeConstMeta => const TaskConstMeta(
        debugName: "discord_dispose",
        argNames: [],
      );

  @override
  Future<void> crateApiApiDiscordInit({required String clientId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(clientId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiDiscordInitConstMeta,
      argValues: [clientId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiDiscordInitConstMeta => const TaskConstMeta(
        debugName: "discord_init",
        argNames: ["clientId"],
      );

  @override
  Future<void> crateApiApiDiscordReconnect() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiDiscordReconnectConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiDiscordReconnectConstMeta =>
      const TaskConstMeta(
        debugName: "discord_reconnect",
        argNames: [],
      );

  @override
  Future<void> crateApiApiDiscordSetActivity({required RPCActivity activity}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_rpc_activity(activity, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiDiscordSetActivityConstMeta,
      argValues: [activity],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiDiscordSetActivityConstMeta =>
      const TaskConstMeta(
        debugName: "discord_set_activity",
        argNames: ["activity"],
      );

  @override
  Future<void> crateApiApiInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  ActivityType dco_decode_activity_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ActivityType.values[raw as int];
  }

  @protected
  ActivityType dco_decode_box_autoadd_activity_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_activity_type(raw);
  }

  @protected
  PlatformInt64 dco_decode_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_i_64(raw);
  }

  @protected
  RPCActivity dco_decode_box_autoadd_rpc_activity(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rpc_activity(raw);
  }

  @protected
  RPCAssets dco_decode_box_autoadd_rpc_assets(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rpc_assets(raw);
  }

  @protected
  RPCParty dco_decode_box_autoadd_rpc_party(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rpc_party(raw);
  }

  @protected
  RPCSecrets dco_decode_box_autoadd_rpc_secrets(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rpc_secrets(raw);
  }

  @protected
  RPCTimestamps dco_decode_box_autoadd_rpc_timestamps(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rpc_timestamps(raw);
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  I32Array2 dco_decode_i_32_array_2(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return I32Array2(dco_decode_list_prim_i_32_strict(raw));
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  Int32List dco_decode_list_prim_i_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Int32List;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<RPCButton> dco_decode_list_rpc_button(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_rpc_button).toList();
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  ActivityType? dco_decode_opt_box_autoadd_activity_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_activity_type(raw);
  }

  @protected
  PlatformInt64? dco_decode_opt_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_64(raw);
  }

  @protected
  RPCAssets? dco_decode_opt_box_autoadd_rpc_assets(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_rpc_assets(raw);
  }

  @protected
  RPCParty? dco_decode_opt_box_autoadd_rpc_party(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_rpc_party(raw);
  }

  @protected
  RPCSecrets? dco_decode_opt_box_autoadd_rpc_secrets(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_rpc_secrets(raw);
  }

  @protected
  RPCTimestamps? dco_decode_opt_box_autoadd_rpc_timestamps(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_rpc_timestamps(raw);
  }

  @protected
  I32Array2? dco_decode_opt_i_32_array_2(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_i_32_array_2(raw);
  }

  @protected
  List<RPCButton>? dco_decode_opt_list_rpc_button(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_rpc_button(raw);
  }

  @protected
  RPCActivity dco_decode_rpc_activity(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return RPCActivity(
      state: dco_decode_opt_String(arr[0]),
      details: dco_decode_opt_String(arr[1]),
      timestamps: dco_decode_opt_box_autoadd_rpc_timestamps(arr[2]),
      party: dco_decode_opt_box_autoadd_rpc_party(arr[3]),
      assets: dco_decode_opt_box_autoadd_rpc_assets(arr[4]),
      secrets: dco_decode_opt_box_autoadd_rpc_secrets(arr[5]),
      buttons: dco_decode_opt_list_rpc_button(arr[6]),
      activityType: dco_decode_opt_box_autoadd_activity_type(arr[7]),
    );
  }

  @protected
  RPCAssets dco_decode_rpc_assets(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RPCAssets(
      largeImage: dco_decode_opt_String(arr[0]),
      largeText: dco_decode_opt_String(arr[1]),
      smallImage: dco_decode_opt_String(arr[2]),
      smallText: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  RPCButton dco_decode_rpc_button(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RPCButton(
      label: dco_decode_String(arr[0]),
      url: dco_decode_String(arr[1]),
    );
  }

  @protected
  RPCParty dco_decode_rpc_party(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RPCParty(
      id: dco_decode_opt_String(arr[0]),
      size: dco_decode_opt_i_32_array_2(arr[1]),
    );
  }

  @protected
  RPCSecrets dco_decode_rpc_secrets(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return RPCSecrets(
      join: dco_decode_opt_String(arr[0]),
      spectate: dco_decode_opt_String(arr[1]),
      matchStr: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  RPCTimestamps dco_decode_rpc_timestamps(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RPCTimestamps(
      start: dco_decode_opt_box_autoadd_i_64(arr[0]),
      end: dco_decode_opt_box_autoadd_i_64(arr[1]),
    );
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  ActivityType sse_decode_activity_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ActivityType.values[inner];
  }

  @protected
  ActivityType sse_decode_box_autoadd_activity_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_activity_type(deserializer));
  }

  @protected
  PlatformInt64 sse_decode_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_64(deserializer));
  }

  @protected
  RPCActivity sse_decode_box_autoadd_rpc_activity(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rpc_activity(deserializer));
  }

  @protected
  RPCAssets sse_decode_box_autoadd_rpc_assets(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rpc_assets(deserializer));
  }

  @protected
  RPCParty sse_decode_box_autoadd_rpc_party(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rpc_party(deserializer));
  }

  @protected
  RPCSecrets sse_decode_box_autoadd_rpc_secrets(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rpc_secrets(deserializer));
  }

  @protected
  RPCTimestamps sse_decode_box_autoadd_rpc_timestamps(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rpc_timestamps(deserializer));
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  I32Array2 sse_decode_i_32_array_2(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_i_32_strict(deserializer);
    return I32Array2(inner);
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  Int32List sse_decode_list_prim_i_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getInt32List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<RPCButton> sse_decode_list_rpc_button(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RPCButton>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rpc_button(deserializer));
    }
    return ans_;
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ActivityType? sse_decode_opt_box_autoadd_activity_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_activity_type(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PlatformInt64? sse_decode_opt_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RPCAssets? sse_decode_opt_box_autoadd_rpc_assets(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rpc_assets(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RPCParty? sse_decode_opt_box_autoadd_rpc_party(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rpc_party(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RPCSecrets? sse_decode_opt_box_autoadd_rpc_secrets(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rpc_secrets(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RPCTimestamps? sse_decode_opt_box_autoadd_rpc_timestamps(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rpc_timestamps(deserializer));
    } else {
      return null;
    }
  }

  @protected
  I32Array2? sse_decode_opt_i_32_array_2(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_i_32_array_2(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<RPCButton>? sse_decode_opt_list_rpc_button(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_rpc_button(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RPCActivity sse_decode_rpc_activity(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_state = sse_decode_opt_String(deserializer);
    var var_details = sse_decode_opt_String(deserializer);
    var var_timestamps =
        sse_decode_opt_box_autoadd_rpc_timestamps(deserializer);
    var var_party = sse_decode_opt_box_autoadd_rpc_party(deserializer);
    var var_assets = sse_decode_opt_box_autoadd_rpc_assets(deserializer);
    var var_secrets = sse_decode_opt_box_autoadd_rpc_secrets(deserializer);
    var var_buttons = sse_decode_opt_list_rpc_button(deserializer);
    var var_activityType =
        sse_decode_opt_box_autoadd_activity_type(deserializer);
    return RPCActivity(
        state: var_state,
        details: var_details,
        timestamps: var_timestamps,
        party: var_party,
        assets: var_assets,
        secrets: var_secrets,
        buttons: var_buttons,
        activityType: var_activityType);
  }

  @protected
  RPCAssets sse_decode_rpc_assets(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_largeImage = sse_decode_opt_String(deserializer);
    var var_largeText = sse_decode_opt_String(deserializer);
    var var_smallImage = sse_decode_opt_String(deserializer);
    var var_smallText = sse_decode_opt_String(deserializer);
    return RPCAssets(
        largeImage: var_largeImage,
        largeText: var_largeText,
        smallImage: var_smallImage,
        smallText: var_smallText);
  }

  @protected
  RPCButton sse_decode_rpc_button(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_label = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    return RPCButton(label: var_label, url: var_url);
  }

  @protected
  RPCParty sse_decode_rpc_party(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_opt_String(deserializer);
    var var_size = sse_decode_opt_i_32_array_2(deserializer);
    return RPCParty(id: var_id, size: var_size);
  }

  @protected
  RPCSecrets sse_decode_rpc_secrets(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_join = sse_decode_opt_String(deserializer);
    var var_spectate = sse_decode_opt_String(deserializer);
    var var_matchStr = sse_decode_opt_String(deserializer);
    return RPCSecrets(
        join: var_join, spectate: var_spectate, matchStr: var_matchStr);
  }

  @protected
  RPCTimestamps sse_decode_rpc_timestamps(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_start = sse_decode_opt_box_autoadd_i_64(deserializer);
    var var_end = sse_decode_opt_box_autoadd_i_64(deserializer);
    return RPCTimestamps(start: var_start, end: var_end);
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_activity_type(ActivityType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_box_autoadd_activity_type(
      ActivityType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_activity_type(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_64(
      PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rpc_activity(
      RPCActivity self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rpc_activity(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rpc_assets(
      RPCAssets self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rpc_assets(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rpc_party(
      RPCParty self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rpc_party(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rpc_secrets(
      RPCSecrets self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rpc_secrets(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rpc_timestamps(
      RPCTimestamps self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rpc_timestamps(self, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_32_array_2(I32Array2 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_i_32_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_list_prim_i_32_strict(
      Int32List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putInt32List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_rpc_button(
      List<RPCButton> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rpc_button(item, serializer);
    }
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_activity_type(
      ActivityType? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_activity_type(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_64(
      PlatformInt64? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rpc_assets(
      RPCAssets? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rpc_assets(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rpc_party(
      RPCParty? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rpc_party(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rpc_secrets(
      RPCSecrets? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rpc_secrets(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rpc_timestamps(
      RPCTimestamps? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rpc_timestamps(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_i_32_array_2(I32Array2? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_i_32_array_2(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_rpc_button(
      List<RPCButton>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_rpc_button(self, serializer);
    }
  }

  @protected
  void sse_encode_rpc_activity(RPCActivity self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.state, serializer);
    sse_encode_opt_String(self.details, serializer);
    sse_encode_opt_box_autoadd_rpc_timestamps(self.timestamps, serializer);
    sse_encode_opt_box_autoadd_rpc_party(self.party, serializer);
    sse_encode_opt_box_autoadd_rpc_assets(self.assets, serializer);
    sse_encode_opt_box_autoadd_rpc_secrets(self.secrets, serializer);
    sse_encode_opt_list_rpc_button(self.buttons, serializer);
    sse_encode_opt_box_autoadd_activity_type(self.activityType, serializer);
  }

  @protected
  void sse_encode_rpc_assets(RPCAssets self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.largeImage, serializer);
    sse_encode_opt_String(self.largeText, serializer);
    sse_encode_opt_String(self.smallImage, serializer);
    sse_encode_opt_String(self.smallText, serializer);
  }

  @protected
  void sse_encode_rpc_button(RPCButton self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.label, serializer);
    sse_encode_String(self.url, serializer);
  }

  @protected
  void sse_encode_rpc_party(RPCParty self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.id, serializer);
    sse_encode_opt_i_32_array_2(self.size, serializer);
  }

  @protected
  void sse_encode_rpc_secrets(RPCSecrets self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.join, serializer);
    sse_encode_opt_String(self.spectate, serializer);
    sse_encode_opt_String(self.matchStr, serializer);
  }

  @protected
  void sse_encode_rpc_timestamps(RPCTimestamps self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_i_64(self.start, serializer);
    sse_encode_opt_box_autoadd_i_64(self.end, serializer);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }
}
